## 事务

数据库中的一组操作，要么都执行，要么都失败

> ACID

1. 原子性（Atomicity）：事务是最小的执行单位，不允许分割

2. 一致性（Consistency）：执行事务前后，数据保持一致

3. 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的

4. 持久性（Durability）：一个事务被提交后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

   只有保证原子性，隔离性，持久性后，才能保证一致性。前三者是手段，后者是目的。

   ### 并发事务导致的问题

   #### 脏读（Dirty Read）

   在事务A读取并修改数据后，还未提交，这个修改对其他事务是可见的，事务B读取了这个还未提交的数据，但事务A回滚，导致数据没有提交到数据库，实际并未被修改，那么此时事务B读取到的就是脏数据。

   #### 丢失修改（Lost to modify）

   在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

   #### 不可重复读（Unrepeatable read）

   指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

   #### 幻读（Phantom read）

   幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

   #### 不可重复读和幻读的区别

   1. 不可重复读：多次读取的同一数据被修改或者记录减少
   2. 幻读：读取的记录数量增加了

   #### 并发事务控制方式

   > 锁和MVCC（多版本并发控制，乐观）

   读写锁：

   - 共享锁（S锁/读锁）：读取记录时获取共享锁，允许多个事务同时获取（锁兼容）
   - 排他锁（X锁/写锁）：事务在修改记录时获取排他锁，不允许多个事务同时获取。

   > InnoDB支持**行级锁**和**表级锁**，行级锁拥有更小的粒度，仅对与操作相关的一条或多条记录上锁

   MVCC：多版本并发控制器，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

   主要使用的手段：**隐藏字段**，**undo log**，**read view**

   - undo log：undo log用于记录某行数据的多个版本的数据
   - read view和隐藏字段：用户判断当前版本的可见性

   ### SQL事务隔离级别

   - **READ-UNCOMMITTED（读取未提交）**：最低的隔离级别，允许读取未提交的数据，可能导致脏读，幻读，不可重复读
   - **READ-COMMITTED（读取已提交）**：允许读取并发事务已提交的数据，可以阻止脏读，可能导致幻读，不可重复读
   - **REPEATABLE-READ（可重复读）**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
   - **SERIALIZABLE（可串行化）**：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

   ### 行级锁分类

   - **记录锁（Record Lock）：**也称记录锁，对单行记录上锁
   - **间隙锁（Gap Lock）：**锁定一个范围，不包括记录本身
   - **临键锁（Next-Key Lock）：**Record Lock + Gap Lock，锁定一个范围包括记录本身。主要为了解决幻读问题，记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

   ### 意向锁
   
   用于判断是否可以对每张表使用表锁
   
   - **意向共享锁（Intention Shared Lock）**：IS锁，事务有意向对表中某些记录加共享锁（S锁）前必须要获取该表的IS锁。
   - **意向排他锁（Intention Exclusive Lock，IX 锁）**：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。
   
   ### 当前读和快照读
   
   - **快照读（一致性非锁定读）：**快照即记录的历史版本，每行记录可能存在多个历史版本。当使用快照读，如果读取的记录正在执行UPDATE或者DELETE操作，读取不会等待X锁的释放，而是会去读取记录的一个快照。
     - 只能在**读取已提交**和**可重读**的隔离级别中使用
     - 读取已提交：读取被锁定记录最新的快照
     - 可重读：读取事务开始时的快照版本
     - **适合对数据一致性要求不是很高且追求极致性能的业务场景**
   - **当前读（一致性锁定读）**：给记录加S/X锁
   
   ### MVCC+Next-Key-Lock防止幻读
   
   1. **执行普通`select`，此时会以`MVCC`快照读的方式读取数据**
   
      在快照都的情况下，RR隔离级别只会在事务开启后的第一次查询生成`Read View`，并使用至事务提交。所以在生成`Read View`之后其他事务所做的更新、插入记录版本对当前事务不可见，实现了可重复读和防止快照读下的“幻读”。
   
   2. **执行 select ... for update/lock in share mode, insert, update, delete等当前读**
   
      在当前读下，读取的数据都是最新的，如果有其他事务插入新的记录，并且刚好发生在当前事务查询范围内，那么就会产生“**幻读**”。`InnoDB`使用**Next-Key-Lock**来防止该问题。在执行当前读时，锁定包括读取记录在内一定范围的记录，阻止其他事务在查询范围内插入数据。

## SQL在MySQL中的执行过程

### [MySQL基础架构分析](https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html#_1-1-mysql-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88)

1. 架构

   - 连接器：身份认证和权限相关（登录MySQL）
   - 查询缓存：执行查询语句时，会先查询缓存（在MySQL8.0版本后移除，因为该功能不太实用）。
   - 分析器：没有命中缓存的话，SQL语句会经过分析器。看SQL语句要做什么，语法有没有错误。
   - 优化器：按照MySQL认为最优的方案执行。
   - 执行器：执行语句，然后从存储引擎返回数据。

   大致分为**Server层**和**存储引擎**

   **Server层：**主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。

   **存储引擎：**主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。

## 缓存机制

### 缓存规则

- 查询缓存会将查询语句和结果集保存在内存（一般是key-value的形式，key是查询语句，value是查询的结果集），再次查询相同结果时直接从内存读取。
- 缓存的结果是通过sessions共享的，所以一个client查询的缓存结果，另一个client也可以使用。
- SQL 必须完全一致才会导致查询缓存命中（大小写、空格、使用的数据库、协议版本、字符集等必须一致）。检查查询缓存时，MySQL Server 不会对 SQL 做任何处理，它精确的使用客户端传来的查询。
- 不缓存查询中的子查询结果集，仅缓存查询最终结果集。
- 不确定的函数将永远不会被缓存, 比如 `now()`、`curdate()`、`last_insert_id()`、`rand()` 等。
- 不缓存产生告警（Warnings）的查询。
- 太大的结果集不会被缓存 (< query_cache_limit)。
- MySQL 缓存在分库分表环境下是不起作用的。

### 内存管理

采用内存池技术，自己管理内存的释放和分配，而不是通过操作系统。

内存池使用的基本单位是变长的block，用来存储类型、大小、数据等信息。一个结果集的缓存通过链表把这些block连接起来。block最短长度为`query_cache_min_res_unit`。

每次都会申请固定大小的数据块，分配时会锁住空间块，所以操作很慢，MySQL会尽量选择小的内存块，不够继续申请，多了释放多余的。

如果余下的空间块很小无法被使用，就会成为碎片。

### 缓存优点

- 缓存发生在SQL语句解析之前，语句只需要通过验证器后就能从缓存中得到结果，无需后续的操作。
- 查询缓存基于内存，减少大量的I/O操作，效率非常高。

### 缓存缺点

- MySQL会对每一条`SELECT`语句通过`Hash`计算，找到该查询的缓存结果是否存在。虽然`Hash`效率非常高，但是在高并发的场景中，依然会带来不小的开销。
- 查询缓存失效。表变更的非常频繁，会造成缓存命中率降低。
- 查询语句只要有一点不一样都无法使用缓存，如大小写，空格的不同，因为它们的Hash值不同。
- 系统变量设置的不合理会产生大量的内存碎片，需要频繁地清理内存。

### 对性能的影响

对读和写都会带来额外的开销

- 读查询之前会检查是否命中缓存。
- 读查询后会将查询语句及结果写入缓存。
- 当某张表写入数据时，有关它的所有缓存都会失效，如果缓存空间大，会使系统僵死一段时间，因为操作依赖于全局锁。

### **适用于**

- 表数据修改不频繁、数据较静态。
- 查询（Select）重复度高。
- 查询结果集小于 1 MB。

### 不适用于

- 表中的数据、表结构或者索引变动频繁
- 重复的查询很少
- 查询的结果集很大

**建议使用Redis等缓存方式**