# 基础概念

## 特点

面向对象（封装，继承，多态）

## 字节码

JVM可理解的代码（`.class` 的文件），它不面对任何特定的处理器，只面向JVM。

## Java和C++的区别

都是面向对象的语言，都支持封装、继承和多态，

不同点：

1. java不支持指针直接访问内存，程序内存更加安全；

2. java的类为单继承，但是接口可以多继承，c++支持多重继承；

3. java有自动内存管理垃圾回收机制（GC），不需要手动释放内存；

4. C++同时支持方法重载和操作符重载，但是JAVA只支持方法重载；

## 成员变量与局部变量的区别

**语法形式**：<mark>成员变量</mark>属于类，而<mark>局部变量</mark>是在代码块或者方法中定义的变量或是方法的参数；成员变量可被`private`,`static`,`public`等修饰符修饰，而局部变量不能被访问控制修饰符及`static`所修饰；都能被`final`修饰。

**存储方式**：如成员变量使用`static`修饰，那么它属于类，否则属于实例；对象存在于堆内存，局部变量存在于栈内存。

**生存时间**：成员变量是对象的一部分，随着对象的创建而存在；局部变量跟随方法的生命周期，调用时创建，结束时消亡。

**默认值**：<mark>成员变量</mark>会被赋予初始值，<mark>局部变量</mark>不会。

## 静态方法为什么不能调用非静态成员？

1. 静态方法属于类，在类加载时就会分配内存，可以通过类名直接访问。非静态方法属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问；

2. 静态方法在类加载时就会存在，此时无法调用在内存中还不存在的非静态成员。

## 重载

发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

存在重载解析，重载就是同一个类中多个同名方法根据<mark>不同的传参</mark>来执行不同的逻辑处理。

## 重写

发生在运行期，子类对父类方法的实现过程的重新编写。

* 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
* 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
* 构造方法无法被重写

## 基本数据类型

| 基本类型      | 位数  | 字节  | 默认值     | 取值范围                                       |
|:---------:|:---:|:---:|:-------:|:------------------------------------------:|
| `byte`    | 8   | 1   | 0       | -128 ~ 127                                 |
| `short`   | 16  | 2   | 0       | -32768 ~ 32767                             |
| `int`     | 32  | 4   | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64  | 8   | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16  | 2   | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32  | 4   | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64  | 8   | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1   |     | false   | true, false                                |

### 基本类型和包装类型的区别

· 成员变量包装类型不赋值就是null，而基本类型不是null;

· 包装类型可用于泛型，而基本类型不可以；

· 基本数据类型的局部变量存放在虚拟机栈的局部变量表中，基本数据类型的成员变量（未被static修饰）存放在JVM的堆中。包装类型属于对象类型，存放在堆中。

· 基本数据类型占用的空间非常小。

## 包装类型的缓存机制

基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`, `Short`, `Integer`, `Long`默认创建数值[-127,128]的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，`Boolean`直接返回`True `or `False`。 

## 自动装箱与拆箱

装箱：将基本类型用对应的引用类型包装起来

拆箱： 将包装类转为基本数据类型

### `Float`会存在精度丢失的问题，可以使用`BigDecimal`进行浮点数的计算



## 接口和抽象类有什么共同点和区别

共同点：

1. 都不能被实例化

2. 都可以包含抽象方法

3. 都可以有默认实现的方法

区别：

1. 一个类只能继承一个类，但是可以实现多个接口

2. 接口中的成员变量只能是`public static final`类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可在子类中被重新定义，也可以重新赋值。

## 浅拷贝

浅拷贝会在堆上创建一个新的对象，如原对象内部存在引用类型，浅拷贝会直接复制内部对象的引用地址，意味着拷贝对象和原对象共用同一个内部对象。

## 深拷贝

完整复制整个对象，包括其中的内部对象。

## 引用对象

两个不同的引用指向同一个对象。

## 为什么重写`equals()`时必须重写`hashcode()`方法？

因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

## String为什么是不可变的？

String本质是字符数组，

1. 保存字符的数据被`final`修饰且为私有，并且`String`类没有暴露修改这个字符串的方法；
2. `final`修饰`String`类导致其无法被继承，从而避免了子类改变`String`

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
	//...
}
```

## 泛型

编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。

#### 1. 泛型类

```java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}
```

实例化泛型类

```java
Generic<Integer> genericInteger = new Generic<Integer>(123456);
```

#### 2. 泛型接口

```java
public interface Generator<T> {
    public T method();
}
```

实现泛型接口，不指定类型：

```java
class GeneratorImpl<T> implements Generator<T>{
    @Override
    public T method() {
        return null;
    }
}
```

实现泛型接口，指定类型：

```java
class GeneratorImpl<T> implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}
```

#### 3. 泛型方法

```java
 public static < E > void printArray( E[] inputArray )
   {
         for ( E element : inputArray ){
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
```

使用：

```java
// 创建不同类型数组： Integer, Double 和 Character
Integer[] intArray = { 1, 2, 3 };
String[] stringArray = { "Hello", "World" };
printArray( intArray  );
printArray( stringArray  );
```

## 注解

可以看作一种特殊的注释，主要用于修饰类、方法或者变量。

#### 注解的解析方法

· 编译期直接扫描

· 运行期通过反射处理： 如Spring框架中的`@Component`, `@Value`。

## 序列化和反序列化

**序列化**：将数据结果或者对象转换为二进制字节流的过程

**反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程



下面是序列化和反序列化常见应用场景：

- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。
